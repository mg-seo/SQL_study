-- INSERT
-- 테이블 구조를 빠르게 확인하는 방법
DESC departments;
SELECT * FROM departments;
-- 1ST
INSERT INTO departments VALUES(280, 'DEVELOPER', NULL, 1700);
-- DML문은 트랜젝션이 항상 기록되는데, ROLLBACK으로 되돌릴 수 있음
ROLLBACK;
-- 2ND
INSERT INTO departments(DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID) VALUES(280, 'DEVELOPER', 1700);

-- INSERT  구문도 서브쿼리가 된다(단일값)
INSERT INTO DEPARTMENTS(DEPARTMENT_ID, DEPARTMENT_NAME) VALUES((SELECT MAX(DEPARTMENT_ID) + 10 FROM DEPARTMENTS), 'DEVELOPER');
-- INSERT 구문의 서브쿼리(여러 행)
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES WHERE 1 = 2); -- 테이블 구조 복사
SELECT * FROM EMPS;
INSERT INTO EMPS(EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)(SELECT EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID FROM EMPLOYEES WHERE JOB_ID = 'SA_MAN');
DESC EMPS;
COMMIT; -- 트랜젝션을 반영함

---------------------------------------------------------------------------------------
-- UPDATE : SELECT로 해당값이 고유한 행인지 확인하고, 업데이트할 것
SELECT * FROM EMPS;
UPDATE EMPS SET SALARY = 1000, COMMISSION_PCT = 0.1 WHERE EMPLOYEE_ID = 148;
ROLLBACK;
UPDATE EMPS SET SALARY = NVL(SALARY, 0) + 1000 WHERE EMPLOYEE_ID >= 145;

-- UPDATE 구문의 서브쿼리
-- 단일값 서브쿼리
UPDATE EMPS SET SALARY = (SELECT SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 100) WHERE EMPLOYEE_ID = 148;
-- 여러값 서브쿼리
UPDATE EMPS
SET (SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
= (SELECT SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 100)
WHERE EMPLOYEE_ID = 140;
-- WHERE 에도 됨
UPDATE EMPS
SET SALARY = 1000
WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG');
-----------------------------------------------------------------------------------------
--DELETE 구문 : 트랜젝션이 있긴하지만, 삭제하기 전에 반드시 SELECT문으로 삭제 조건에 해당하는 데이터를 꼭 확인하는 습관을 들이자
SELECT * FROM EMPS WHERE EMPLOYEE_ID = 148;
DELETE FROM EMPS WHERE EMPLOYEE_ID = 148; --KEY를 통해 지우는 편이 좋다
--DELETE에 서브쿼리
DELETE FROM EMPS WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 80);
ROLLBACK;
-- DELETE문이 전부 실행되는 것은 아닙니다.
-- 테이블이 연간관계(FK) 제약을 가지고 있다면, 지워지지 않습니다.(참조무결성 제약)
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
DELETE FROM DEPARTMENTS WHERE DEPARTMENT_ID = 100; -- EMPLOYEES 에서 100번 데이터를 FK로 사용하고 있어서 지울 수 없다
--------------------------------------------------------------------------------------------
-- MERGE문 : 타겟테이블 데이터가 있으면 UPDATE, 없으면 INSERT구문을 수행하는 병합
SELECT * FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG';
MERGE INTO EMPS A -- 타겟테이블
USING (SELECT * FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG') B -- 합칠테이블
ON (A.EMPLOYEE_ID = B.EMPLOYEE_ID)
WHEN MATCHED THEN -- 일치하는 경우
    UPDATE SET A.SALARY = B.SALARY,
               A.COMMISSION_PCT = B.COMMISSION_PCT,
               A.HIRE_DATE = SYSDATE
WHEN NOT MATCHED THEN -- 일치하지 않는 경우
    INSERT (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
    VALUES (B.LAST_NAME, B.EMAIL, B.HIRE_DATE, B.JOB_ID);

SELECT * FROM EMPS;
ROLLBACK;

-- 서브쿼리 절로 다른테이블을 가져오는게 아니라, 직접 값을 넣을 때 DUAL을 쓸 수도 있습니다
MERGE INTO EMPS A
USING DUAL
ON (A.EMPLOYEE_ID = 107) --조건
WHEN MATCHED THEN
    UPDATE SET A.SALARY = 10000,
               A.COMMISSION_PCT = 0.1,
               A.DEPARTMENT_ID = 100
WHEN NOT MATCHED THEN
    INSERT (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
    VALUES (107, 'HONG', 'EXAMPLE', SYSDATE, 'DBA');
SELECT * FROM EMPS;
-------------------------------------------------------------------------------
DROP TABLE EMPS;
-- CTAS: 테이블 구조 복사
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES); -- 데이터까지 복사
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES WHERE 1 = 2); -- 구조만 복사
SELECT * FROM EMPS;